# README — почему «живой» обмен между `objects.js` и `program.js` в GEE не работает

## TL;DR

Автопоявление новых областей, нарисованных в `objects.js`, в выпадающем списке `program.js` **невозможно** в пределах двух раздельных скриптов Code Editor без внешнего хранилища/API. Причина — архитектура Google Earth Engine: кэширование модулей, изоляция окружений, отсутствие перезаписи ассетов «на месте» и запрет на прямой межскриптовый обмен.

---

## Проблемы и причины

1. **Кэширование `require()`**

    * **Что есть:** модуль, подключённый через `require()`, поднимается и кэшируется на сервере **один раз** на сессию.
    * **Следствие:** повторные вызовы не видят новых данных; «обновить список мест» простым `require()` нельзя.

2. **Изоляция контекстов**

    * **Что есть:** каждый скрипт (и подтянутый модуль) исполняется в отдельной песочнице; общих глобалов и общей памяти нет.
    * **Следствие:** межмодульные колбэки/события не проходят; `objects.js` не может «пушнуть» изменения в `program.js`.

3. **Нестойкость клиентского состояния**

    * **Что есть:** переменные и UI-состояние живут только в текущем запуске; при новом запуске всё пересоздаётся.
    * **Следствие:** любые «временные» объекты (типа `newAreas`) исчезают и не доступны другим скриптам.

4. **Серверная модель `ee.*` (ленивая, иммутабельная)**

    * **Что есть:** `ee.FeatureCollection` — серверный объект; операции над ним формируют новый граф вычислений, а не мутируют существующий.
    * **Следствие:** «добавить фичу внутрь ассета» нельзя — только собрать **новую** коллекцию и переинжестить.

5. **Перезаписи ассетов из Code Editor нет**

    * **Что есть:** в UI загрузчика/экспорта отсутствует режим overwrite; при существующем `assetId` экспорт падает с *already exists*.
    * **Следствие:** перезаписать «файл-ассет» напрямую нельзя. Нужны либо ручное удаление/новый `assetId`, либо CLI/API с флагом принудительной перезаписи.

6. **Нет межскриптового IPC/сетевых вызовов**

    * **Что есть:** в Code Editor запрещены произвольные HTTP/WebSocket для скриптов; нет встроенного KV/шины событий между скриптами.
    * **Следствие:** нельзя «пингануть» другой скрипт или отправить ему данные напрямую (кроме костылей вроде URL-параметров).

7. **Обновление страницы не помогает**

    * **Что есть:** рефреш браузера перезапускает клиент, но **не сбрасывает** серверные кэши модулей в рамках той же сессии.
    * **Следствие:** даже после F5 `program.js` продолжит видеть старое состояние импортов.

8. **Асинхронность задач и квоты**

    * **Что есть:** запись данных возможна только через экспорт/ингест; задачи выполняются асинхронно и подчиняются квотам/правам.
    * **Следствие:** «моментального» появления новых геометрий в другом скрипте быть не может — всегда есть задержка.

---

## Что из этого следует (нельзя сделать)

* ❌ Автоматически «подхватывать» изменения из `objects.js` в `program.js` через `require()`, колбэки или общие переменные.
* ❌ Мутировать существующий `FeatureCollection`-ассет «по месту» из Code Editor.
* ❌ Хранить общее состояние между скриптами без внешнего персистентного слоя.

---

## Что можно (поддерживаемые обходные пути)

* ✅ **Мастер-ассет с пересборкой**: читать текущий FC, добавлять новые фичи и **переинжестить** (UI: удалить старый ассет → экспорт с тем же ID; либо **CLI/API** с overwrite/`--force`).
* ✅ **Версионирование ассетов**: писать в `places_YYYYMMDD_HHMMSS` и передавать актуальный `assetId` в `program.js` (например, через `ui.url`).
* ✅ **Один скрипт** вместо двух: всё состояние и UI в одном файле (квази-сохранение — через URL-параметры).
* ✅ **Внешнее хранилище/бэкенд** (Sheets/Firestore/Cloud Storage + Cloud Function) с синхронизацией в мастер-ассет через EE API.

---

## Резюме

Требуемая «динамика» упирается в дизайн GEE: кэш модулей, изоляция исполнений и иммутабельная модель данных. Поэтому «живо обмениваться» между раздельными скриптами без внешнего слоя **нельзя**. Рабочие сценарии — через пересборку ассета (лучше с API/CLI), версионирование, объединение в один скрипт или вынос состояния во внешний сторедж.
